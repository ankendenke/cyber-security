The process of imaging a disk starts by identifying the target drive, preparing it for imaging, and then creating the image file which is later verified for integrity. This needs to be performed in an environment that allows us to perform these tasks and also ensures the process is properly logged.  

Each operating system has specific file system structures and configurations that require different imaging tools and techniques. In our scenario, we will use Linux as the OS to acquire the data and create a forensic image of a drive. The use of open-source software for image acquisition is an advantage in many cases since it can satisfy guidelines for evidential reliability that need to be fulfilled. The Linux kernel also supports many [file systems](https://en.wikipedia.org/wiki/Category:File_systems_supported_by_the_Linux_kernel), which is a big advantage when analyzing different media types.

Start the attached machine in this task by clicking the Start Machine button. A split-screen view of the VM will appear. In case the VM is not visible, use the blue Show Split View button at the top of the page. Alternatively, you can access the machine via SSH using the following credentials below.  

![THM Key Credentials](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/be629720b11a294819516c1d4e738c92.png)

|   |   |
|---|---|
|**Username**|analyst|
|**Password**|forensics|
|**IP**|MACHINE_IP|

Write-Blockers  

It is important to mention that [write-blockers](https://en.wikipedia.org/wiki/Forensic_disk_controller) [](https://en.wikipedia.org/wiki/Forensic_disk_controller)are usually required when manipulating physical disks. A **write-blocker** is a device used to prevent any modifications to data on a storage device during analysis. It ensures reading data without risking changes to the original evidence.

Write-blockers work by physically intercepting all drive commands that write data sent between the disk being imaged and the OS attached to it.

Audit Trail   

An audit trail is a chronological record that tracks actions and events within a system, providing a detailed history for accountability and security. It ensures traceability by documenting each step. This step can be performed with different parameters depending on the legal or [compliance framework required](https://assets.publishing.service.gov.uk/media/64da431cc8dee4000d7f1c1e/FINAL_2023.1.18_Code_of_Practice.pdf) by the task.

We can manually or automatically record the actions and events with varying detail levels. Since we need to preserve the evidence and keep track of our activities, let's explore some methods for tracking tasks and automating command-line activity logging to help us have this audit trail of our process.

If we are using `bash`, the `history` command can help us log our activity. It can be saved using a timestamp and preserved in a file. Below, we can observe a chart with some commands recommended to use during our session.

|   |   |
|---|---|
|`set -o history`|Enables command history in the shell, allowing it to record the commands you enter.|
|`shopt -s histappend`|Ensures that the command history is appended to the history file instead of overwriting it when the shell exits.|
|`export HISTCONTROL=`|Clears any settings that control which commands are saved in the history, ensuring all commands are recorded.|
|`export HISTIGNORE=`|Clears any settings that ignore specific patterns of commands, so all commands are saved in the history.|
|`export HISTFILE=~/.bash_history`|Sets the file where the command history is saved.|
|`export HISTFILESIZE=-1`|Sets no limit on the number of lines stored in the history file.|
|`export HISTSIZE=-1`|Sets no limit on the number of commands retained in the shell history.|
|`export HISTTIMEFORMAT="%F-%R "`|Formats timestamps in the history as "YYYY-MM-DD HH" for each command.|

Another good practice is to log all sessions. This could be achieved with bash internals, but other easy-to-use software can achieve the same, like [script](https://man7.org/linux/man-pages/man1/script.1.html), a UNIX tool present in several Linux distributions, or similar tools like [ttyrec](https://github.com/mjording/ttyrec).

Finally, we should always save the output of any command we execute to a file if possible. While this may not be the case in the next examples, this is to provide a more analytic approach to them, but it's recommended to do it in a real scenario.  

Again, these requirements can be more demanding depending on the legal frameworks and the needs of the investigation.

Accessing the File System  

While the disk and devices used may differ depending on the requirements and the environment, the process is similar for all disks physically or virtually attached to the Linux OS. Once we have our preparation setup and logging our steps, let's execute the `df` command to see the attached devices on the target machine.

Example Terminal

```shell-session
user@tryhackme$ df
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/root       40581564 7240136  33325044  18% /
devtmpfs          995480       0    995480   0% /dev
tmpfs            1003808       0   1003808   0% /dev/shm
tmpfs             200764    1148    199616   1% /run
tmpfs               5120       0      5120   0% /run/lock
tmpfs            1003808       0   1003808   0% /sys/fs/cgroup
/dev/loop0         25600   25600         0 100% /snap/amazon-ssm-agent/7628
/dev/loop1         25856   25856         0 100% /snap/amazon-ssm-agent/7993
/dev/loop2        108032  108032         0 100% /snap/core/16574
/dev/loop3        106752  106752         0 100% /snap/core/17200
/dev/loop4         57088   57088         0 100% /snap/core18/2812
/dev/loop5         57088   57088         0 100% /snap/core18/2829
/dev/loop6         65536   65536         0 100% /snap/core20/2105
/dev/loop7         65536   65536         0 100% /snap/core20/2318
/dev/loop8         69632   69632         0 100% /snap/lxd/22526
/dev/loop9         94080   94080         0 100% /snap/lxd/24061
tmpfs             200760       0    200760   0% /run/user/1000
tmpfs             200760       8    200752   1% /run/user/114
tmpfs             200760       4    200756   1% /run/user/1001
```

Drives are attached as devices under the `/dev` directory. In the output above, the current disk used by the OS is listed under `/dev/root`. Our device is not mounted yet, and since it is a Virtual Disk attached to a `loop interface`, it will not appear using the command `df`. This is also common for physical disks when not directly attached.  

We can still list block devices using the `lsblk` command with the `-a` option to list all devices, as shown below.

Example Terminal

```shell-session
user@tryhackme$ lsblk -a
NAME    MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
loop0     7:0    0  26.7M  1 loop /snap/amazon-ssm-agent/5163
loop1     7:1    0  24.9M  1 loop /snap/amazon-ssm-agent/7628
loop2     7:2    0 105.4M  1 loop /snap/core/16574
loop3     7:3    0 104.2M  1 loop /snap/core/17200
loop4     7:4    0  55.7M  1 loop /snap/core18/2812
loop5     7:5    0  55.7M  1 loop /snap/core18/2829
loop6     7:6    0  63.9M  1 loop /snap/core20/2105
loop7     7:7    0    64M  1 loop /snap/core20/2318
loop8     7:8    0  67.9M  1 loop /snap/lxd/22526
loop9     7:9    0  91.9M  1 loop /snap/lxd/24061
loop10    7:10   0   1.1G  0 loop  
loop11    7:11   0         0 loop 
xvda    202:0    0    40G  0 disk 
└─xvda1 202:1    0    40G  0 part /
```

Above, we can observe the `loop10` interface initialized with 1.1 GB, which matches our Disk Size. This should also be noticed since we need to know that we have enough space to create the images either on the disk we will copy it or on the disk where we will save the image. In our case, is the `xdva` block, which corresponds to the `/dev/root/`. The partition is 40 GB in size. 

We can get more info about the device using the `losetup` command with the `-l` option to list the device and the assigned interface path, in this case `/dev/loop10`. 

Forensic Imaging

```shell-session
user@tryhackme$ sudo losetup -l /dev/loop10
NAME        SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE                 DIO LOG-SEC
/dev/loop10         0      0         0  0 /home/ubuntu/example1.img   0     512
```

It is possible to acquire further information like the UUID of the image using the `blkid` with the interface as an argument, as demonstrated in the following example.

Forensic Imaging

```shell-session
user@tryhackme$ sudo blkid /dev/loop10
/dev/loop10: UUID="1895de04-f9ee-4b8b-b49d-9ef55770073c" TYPE="ext4"
```

With the information above logged into our notes, we should proceed to create the disk's image. Note that if we were using a physical disk, we could also use commands like `hparn` to get information about the manufacturer, serial number, and other required data.