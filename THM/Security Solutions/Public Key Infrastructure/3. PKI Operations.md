## How PKI Works

Understanding what a certificate is and its purpose is "key" to understanding PKI. One of the most crucial purposes of PKI is to verify the integrity of data being exchanged and its trust within parties, or, in other words, authentication. This is done thanks to a certificate. You can start putting the pieces together and see why a certificate has components like CN and metadata about its owner. As we saw in the previous task, a digital certificate provides an identity for an entity. This doesn't have to be human; it can be anything, including software, servers, or processes. 

**Example Scenario**

It's very common to see PKI in corporations that handle public-facing services to manage and issue SSL certificates. Imagine a company that partners or white labels its service with other companies, like a payment portal, buy now, pay later integrations, or credit checks. There are likely going to be a lot of integrations for these payment portals with merchants like retail stores or banks. They would have to establish Mutual TLS (mTLS) connections, tunnelling or high levels of encryption to protect the data and handle all the logistics, right? How would these certificates be shared, generated, and managed? You wouldn't do it manually; you'd have servers that would speak to a CA to issue a certificate, then servers to distribute them, sign them internally, and also handle rotation or revocation. This conglomeration of servers, logistics, and inventory management would be an example of a PKI infrastructure.

**Certificate Authorities**

How do you know if a certificate is legitimate? Imagine you log in to your bank, so you, as the client, send a request to the bank's server to display your account information in their online banking dashboard. This will only happen if the bank can verify your digital certificate generated by the same CA trusted by the bank. In a nutshell, Certificate Authorities (CAs) help us know if a certificate is legitimate by providing third-party trust and verification. Examples of CAs are GlobalSign and Digicert.

**Acquiring a CA Certificate**

To generate a CA certificate, you follow a few steps:

1. First, you need to generate a private key that the CA will use. For example, a 4096 RSA key.
2. Once you have the private key, generate a Certificate Signing Request (example-certificate.csr). This is the file used to request a certificate from a CA. It has all the information about your organisation, entity, etc., which the CA will need to generate the signed certificate. When you generate a CSR using commands like OpenSSL, it asks you for the metadata information, and you configure all the details.
3. After the CSR is generated, you can submit it to the CA chosen. This typically involves raising a purchase order and some admin work. If you are lucky enough to have an automated infrastructure, you can use tools that have built-in connectors to perform these operations, in the case of a new certificate needed or rotation, for example.

Self-Signed Certificates vs. Trusted CA Certificates

Acquiring a certificate with a CA can be a long process; you create the certificate and send it to a CA to sign it for you. This process can take weeks if you don't have tools and automation in place. Self-signed certificates are signed by an entity, usually the same one that authenticates. Browsers generally do not trust self-signed certificates because there is no third-party verification. The browser has no way of knowing if the certificate is authentic or if it's being used for malicious purposes (like a man-in-the-middle attack).

Trusted CA certificates, on the other hand, are verified by a CA, which acts as a trusted third party to confirm the website's identity. An issued certificate sometimes take a long time; if you want to test a development environment, it can make sense to use self-signed certificates. Ideally, this is an internal, air-gapped environment without connection to the public Internet. Otherwise, it defeats the purpose of a certificate: the entire system of secure communication relies on the fact that both parties (the browser and the server) can trust the data being exchanged and that no one in the middle can intercept or modify it without detection.

**How Does PKI Authenticate Certificates?**

PKI works by encrypting data with a certificate; it typically uses the public key to encrypt the data and the private key held by the certificate to decrypt it. The private key is held by the certificate owner, while the public one is distributed publicly. The public key is shared with whoever requests verification of the owner's identity. However, depending on the use case, the public key can also be used for decryption.

![PKI authentication diagram](https://tryhackme-images.s3.amazonaws.com/user-uploads/61a7523c029d1c004fac97b3/room-content/61a7523c029d1c004fac97b3-1736354605088.png)

Imagine a bank, the same one we used as an example earlier, where the certificate owner (user) encrypts it with the private key and then hands over the public key to the bank. The bank would decrypt it with the public key, verify the identity and log them in. One important thing to note here, and one of the main drivers for establishing frameworks like PKI, is that the decryption key can only decrypt the same data that the pair counterpart has been used for encryption. If the data has been illegally tampered with during transmission, the decryption key will fail to decrypt.