As we continue our investigation, we should focus on the system's users and groups. In doing so, we may uncover evidence of the attacker moving laterally or maintaining access throughout the system by exploiting additional vulnerabilities.

Identifying User Accounts

Within UNIX-like systems, the _/etc/_ directory is a central location that stores configuration files and system-wide settings. Specifically, when investigating user accounts, `/etc/passwd` is a colon-separated plaintext file that contains a list of the system's accounts and their attributes, such as the user ID (UID), group ID (GID), home directory location, and the login shell defined for the user.

Let's view the user accounts on the affected system by reading the file:

Viewing the Contents of /etc/passwd

```shell-session
investigator@10.10.33.136:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
```

Attackers can maintain access to a system by creating a backdoor user with root permissions. We can leverage the `cut` and `grep` commands to identify this type of user account backdoor quickly. The following command extracts and displays all user accounts with the user ID (UID) of 0. The presence of a user with UID 0, other than the legitimate root user account, can quickly suggest a potential backdoor account.

Filtering the Contents of /etc/passwd

```shell-session
investigator@10.10.33.136:~$ cat /etc/passwd | cut -d: -f1,3 | grep ':0$'
root:0
**********:0
```

In the above command, we first display the contents of the `/etc/passwd` file. We then take the contents and perform a `cut` action to extract only the first (username) and third (user ID) fields from each line, delimited (`-d` by the `:` character. We then use the `grep` command to extract specific entries containing `:0`, signifying a user ID of 0.

This, however, is not a foolproof method, as the backdoor account could have been created with legitimate user and group IDs. For further investigation, we can take a look at **groups**.

Identifying Groups

In Linux systems, certain groups grant specific privileges that attackers may target to escalate their privileges. Some important Linux groups that might be of interest to an attacker include:

- **sudo** or **wheel**: Members of the sudo (or wheel) group have the authority to execute commands with elevated privileges using sudo.
- **adm**: The adm group typically has read access to system log files.
- **shadow**: The shadow group is related to managing user authentication and password information. With this membership, a user can read the `/etc/shadow` file, which contains the password hashes of all users on the system.
- **disk**: Members of the disk group have almost unrestricted read and limited write access inside the system.

We can view all of the groups (and their respective group IDs) on the system by reading the `/etc/group` file:

Viewing the Contents of /etc/group

```shell-session
investigator@10.10.33.136:~$ cat /etc/group
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:syslog,ubuntu,investigator
...
```

To determine which groups a specific user is a member of, we can run the following command:

Viewing a Specific Users' Groups

```shell-session
investigator@10.10.33.136:~$ groups investigator
investigator : investigator adm dialout cdrom floppy sudo audio dip video plugdev netdev lxd
```

Alternatively, to list all of the members of a specific group, we can run the following command:

Viewing a Specific Groups' Users

```shell-session
investigator@10.10.33.136:~$ getent group adm
adm:x:4:syslog,ubuntu,investigator
```

If multiple users are in a group (as seen above), their usernames will be listed in a comma-separated format in the entry.

To list all users in the _sudo_ group, we can provide either the name "sudo" or the group ID, typically _27_.

Viewing Group Members by Group ID

```shell-session
investigator@10.10.33.136:~$ getent group 27
sudo:x:27:ubuntu,investigator
```

User Logins and Activity

Checking user logins and activity is valuable for performing a real-time analysis of a compromised system. Fortunately, a couple of useful utilities and logs can assist us.

**last and lastb**

The `last` command is an excellent tool for examining user logins and sessions. It is used to display the history of the last logged-in users. It works by reading the `/var/log/wtmp` file, which is a file that contains every login and logout activity on the system. Similarly, `lastb` specifically tracks failed login attempts by reading the contents of `/var/log/btmp`, which can help identify login and password attacks.

last Example

```shell-session
investigator@10.10.33.136:~$ last
investig pts/1        10.10.152.206    Tue Feb 13 02:37   still logged in
investig pts/0        10.10.101.34     Tue Feb 13 02:29   still logged in
reboot   system boot  5.4.0-1029-aws   Tue Feb 13 02:28   still running
investig pts/1        10.10.101.34     Tue Feb 13 02:23 - crash  (00:05)
investig pts/0        10.10.101.34     Tue Feb 13 02:16 - 02:22  (00:05)
reboot   system boot  5.4.0-1029-aws   Tue Feb 13 02:14   still running
...
```

**lastlog**

Unlike the `last` command, which provides information about all user logins, the `lastlog` command focuses on a user's most recent login activity and reads from the `/var/log/lastlog` file.

lastlog Example

```shell-session
investigator@10.10.33.136:~$ lastlog
Username         Port     From             Latest
root                                       **Never logged in**
daemon                                     **Never logged in**
bin                                        **Never logged in**
sys                                        **Never logged in**
sync                                       **Never logged in**
...
```

**Failed Login Attempts**

In addition to `lastb`, there are other ways to view failed login attempts on Linux through specific log files. The `/var/log/auth.log` file (or `/var/log/secure` on some distributions like CentOS or Red Hat) contains records of authentication-related events, including both successful and failed login attempts.

**who**

The `who` command is a very straightforward command that can be used to display the users that are currently logged into the system. The output of this command can provide details such as the name of the user logged in, the terminal device used, the time that the session was established, idle activity, the process ID of the shell, and additional comments that may include details such as the initial command used to start the session.

who Example

```shell-session
investigator@10.10.33.136:~$ who
investigator pts/0        2024-02-13 02:29 (10.10.101.34)
```

Sudo

The `/etc/sudoers` file is a particularly sensitive configuration file within Unix-like systems. It determines which users possess sudo privileges, enabling them to execute commands as other users, typically the root user.

As a result, it can be a target for attackers seeking persistence. For instance, if an attacker can find a way to insert their user account (or one that they control) into the sudoers file, they could grant themselves elevated privileges without requiring authentication. Alternatively, they may alter existing entries to broaden their access.

For example, a line in a sudoers file might look like this:

/etc/sudoers Example

```shell-session
user@tryhackme$ sudo cat /etc/sudoers
richard   ALL=(ALL) /sbin/ifconfig
```

More specifically, this line specifies:

- **richard** is the username being granted sudo privileges.
- **ALL** indicates that the privilege applies to all hosts.
- **(ALL)** specifies that the user can run the command as any user.
- `/sbin/ifconfig` is the path to the specific binary, in this case, the ifconfig utility.

With this configuration, Richard can execute `ifconfig` with elevated sudo privileges to manage network interfaces as necessary.