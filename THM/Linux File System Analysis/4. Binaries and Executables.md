Another area to look at within our compromised host's file system is identifying binaries and executables that the attacker may have created, altered, or exploited through permission misconfigurations.

Identifying Suspicious Binaries

We can use the `find` command on UNIX-based systems to discover all executable files within the filesystem quickly:

Listing all Executable Binaries on the System

```shell-session
investigator@10.10.33.136:~$ find / -type f -executable 2> /dev/null
/snap/core/16574/etc/init.d/single
/snap/core/16574/etc/init.d/ssh
/snap/core/16574/etc/init.d/ubuntu-fan
/snap/core/16574/etc/init.d/udev
...
```

The following command recursively traverses the file system starting from the root directory and lists any executable file it finds. Note that this provides a huge amount of output. As such, it's often a good idea to limit the scope of the search through additional parameters.

Once we identify an executable or binary that we want to investigate further, we can perform metadata analysis as we have done previously, performing integrity checking on it using checksums or inspecting its human-readable strings and raw content.

Strings

The `strings` command is valuable for extracting human-readable strings from binary files. These strings can sometimes include function names, variable names, and even plain text messages embedded within the binary. Analysing this information can help responders determine what the binary is used for and if there is any potential malicious activity involved. To run the strings command on a file, we need to provide the file as a single argument:

strings Example

```shell-session
user@tryhackme$ strings example.elf
```

Debsums

Like the integrity checking we performed earlier, `debsums` is a command-line utility for Debian-based Linux systems that verifies the integrity of installed package files. `debsums` automatically compares the MD5 checksums of files installed from Debian packages against the known checksums stored in the package's metadata.

If any files have been modified or corrupted, `debsums` will report them, citing potential issues with the package's integrity. This can be useful in detecting malicious modifications and integrity issues within the system's packages. We can perform this check on the compromised system by running the following command:

Scanning Packages with debsums

```shell-session
investigator@10.10.33.136:~$ sudo debsums -e -s
debsums: changed file /***/******* (from sudo package)
```

In the above command, we provide the `-e` flag to only perform a configuration file check. In addition, we provide the `-s` flag to silence any error output that may fill the screen.

Binary Permissions

SetUID (SUID) and SetGID (SGID) are special permission bits in Unix operating systems. These permission bits change the behaviour of executable files, allowing them to run with the privileges of the file owner or group rather than the privileges of the user who executes the file.

If a binary or executable on the system is misconfigured with an SUID or SGID permission set, an attacker may abuse the binary to break out of a restricted (unprivileged) shell through legitimate but unintended use of that binary. For example, if the PHP binary contained a SUID bit to run as root, it's trivial for an attacker to abuse it to run system commands through PHP's system exec functions as root.

Identifying SetUID (SUID) binaries on a Linux system involves examining the file permissions and explicitly looking for executables with the SetUID bit set. We can return to the `find` command to retrieve a list of the SetUID binaries on the system:

Listing SUID Binaries with find

```shell-session
investigator@10.10.33.136:~$ find / -perm -u=s -type f 2>/dev/null
...
/usr/bin/fusermount
/usr/bin/python3.8
/usr/bin/at
/usr/bin/mount
/var/tmp/bash
/mnt/usb/lib/dbus-1.0/dbus-daemon-launch-helper
...
```

Specifically, the above command looks for files where the user permission has the SUID bit set (`-u=s`).

Much of the output here is expected as these binaries require the SUID bit and are not vulnerable. However, two of these results stand out. Firstly, Python should never be given SUID permission, as it is trivial to escalate privileges to the owner. Additionally, any SUID binaries in the `/tmp` or `/var/tmp` directory stand out as these directories are typically writable by all users, and unauthorised creation of SUID binaries in these directories poses a notable risk.

We can investigate further by looking in Jane's bash history for any commands related to Python or bash:

Correlating SUID Abuse in bash_history

```shell-session
investigator@10.10.33.136:~$ sudo cat /home/jane/.bash_history | grep -B 2 -A 2 "python"
ls -al
find / -perm -u=s -type f 2>/dev/null
/usr/bin/python3.8 -c 'import os; os.execl("/bin/sh", "sh", "-p", "-c", "cp /bin/bash /var/tmp/bash && chown root:root /var/tmp/bash && chmod +s /var/tmp/bash")'
ls -al /var/tmp
/var/tmp/bash -p
exit
```

From the output, we've discovered evidence of Jane's user account identifying SUID binaries with the `find` command and abusing the SUID permission on the Python binary to run system commands as the root user. With this level of command execution, the attacker was able to create a copy of the `/bin/bash` binary (the Bash shell executable) and place it into the `/var/tmp` folder. Additionally, the attacker changed the owner of this file to root and added the SUID permission to it (`chmod +s`).

After making an SUID copy of `/bin/bash`, the attacker elevated to root by running `/var/tmp/bash -p`. We can further verify the `bash` binary by performing an integrity check on the original:

Integrity Checking the Suspicious SUID Binary

```shell-session
investigator@10.10.33.136:~$ md5sum /var/tmp/bash 
7063c393************d3b340f1ad2c  /var/tmp/bash
investigator@10.10.33.136:~$ md5sum /bin/bash
7063c393************d3b340f1ad2c  /bin/bash
```

The output above shows that the two binaries are identical, further enhancing our understanding of the attacker's actions to escalate to root.