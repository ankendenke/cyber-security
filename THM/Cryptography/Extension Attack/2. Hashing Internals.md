## How Hash Functions Process Data

Hash functions like MD5, SHA-1, and SHA-256 don't process data all at once. Instead, they break it down into fixed-size chunks. For example, SHA-256 uses 512-bit blocks. If the data doesn't perfectly fit into these blocks, it gets padded. Padding is essential because it ensures that the data fits the exact block size needed for the hash function to do its job.

## Why Padding Matters

Padding isn't just filler—it serves two critical purposes:

1. **Data Alignment**: The data needs to be aligned to the exact block size (like 512 bits for SHA-256). So, if your message is shorter, padding fills up the remaining space.
2. **Message Integrity**: At the end of the padding, the length of the original message is added. This makes sure that any changes to the message can be detected later on.

Let's say you have a message that's 448 bits long. SHA-256 works with 512-bit blocks, so we need to pad the message to fill out the remaining 64 bits. You'd add a "1" bit followed by 63 "0" bits to make the message a full 512 bits. After that, the length of the original message is added to the final 64 bits of the last block.

In simple terms, it will be: 448 + 1(1 bit) + 63(0 bits) = 512 Bits

So if the message is exactly 448 bits, it fits into one block. The block includes the message, a "1" bit, and 63 bits for padding, including the 64-bit length at the end. If the message plus padding exceeds the block size, a new block is added for the length encoding.

## How Hash Functions Use States

Once the data is padded, the hash function processes it block by block, updating its internal state each time. This internal state is a collection of fixed-size values (called registers) that store intermediate results. Each time a block is processed, the hash function tweaks these values, working through rounds of transformations (like bitwise operations and additions) until all the data has been processed.

For example, **SHA-256** has 8 words (A, B, C, D, E, F, G, H) in its internal state, and these values get updated each time a block is processed. The idea is to scramble the data so thoroughly that even a tiny change in the input will completely change the final hash.

## Breakdown of Popular Hash Functions

Let's take a closer look at some popular hash functions and how they work:

## MD5

- **Block size**: 512 bits
- **Internal state**: 128 bits, split into 4 registers (A, B, C, D)
- **Rounds**: MD5 processes each block of data through 64 rounds of operations, which involve things like addition, bitwise shifts, and XOR (exclusive OR) operations.

Click to enlarge the image.

![MD5 hashing process](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/645b19f5d5848d004ab9c9e2-1738669171727.png)

**Why it's vulnerable**: MD5's internal state and padding are predictable, making it vulnerable to attacks like length extension, where an attacker can append data to a message and still generate a valid hash. This hash function is also obsolete for security-sensitive applications due to collision vulnerabilities.

For example, the files [hello](https://www.mscs.dal.ca/~selinger/md5collision/hello) and [erase](https://www.mscs.dal.ca/~selinger/md5collision/erase) have the same md5sum.

![Same md5sum from two different files](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/645b19f5d5848d004ab9c9e2-1731935615625.png)

## SHA-1

- **Block size**: 512 bits
- **Internal state**: 160 bits, split into 5 words (A, B, C, D, E)
- **Rounds**: SHA-1 processes each block through 80 rounds of transformations, much like MD5, but with more complexity.

Click to enlarge the image.

![SHA-1 hashing process](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/645b19f5d5848d004ab9c9e2-1738669171619.png)

**Why it's vulnerable**: SHA-1 has been proven to have weaknesses in its ability to prevent collisions, and like MD5, it's vulnerable to length extension attacks. This is why it's considered outdated for modern security. Similarly to MD5, this hash function is also obsolete for security-sensitive _applications_ due to collision vulnerabilities.

## SHA-256

- **Block size**: 512 bits
- **Internal state**: 256 bits, split into 8 words (A, B, C, D, E, F, G, H)
- **Rounds**: SHA-256 processes each block through 64 rounds of operations, updating its state with bitwise shifts, rotations, and additions.

Click to enlarge the image.

**![SHA-256 hashing process](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/645b19f5d5848d004ab9c9e2-1738669171615.png)**

**Why it's better but not perfect**: SHA-256 is much stronger than MD5 and SHA-1, but it's still vulnerable to length extension attacks if used incorrectly—especially if it's used without a secret key (like in HMAC).

## How Padding and State Manipulation Work

To make this more concrete, imagine you're hashing the message "TryHackMe." The message gets padded until it fits into a 512-bit block. Then, the hash function initializes its internal state and starts crunching through the data, block by block. With each block processed, the internal state gets updated through multiple rounds of operations. By the end of the process, you get a hash that represents the entire input, with even the smallest changes in the message completely altering the final result.

## SHA-256 Hashing Process

![SHA-256 hashing process animation showing the padding process, initial state setup, hash computation, and final hash generation.](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/51f1cc226907fa840f4e6ea59691298e.gif)

_Animation #1_

Before hashing begins, the input message must be structured correctly to meet the **512-bit block size requirement** of SHA-256.

**Padding Process**

- The input message, **"TryHackMe"**, is displayed in block letters.
- SHA-256 operates on **512-bit chunks**, but "TryHackMe" is too short. To meet this requirement, **extra data is added** at the end of the message.
- The animation shows **a total of 16 blocks**, but since "TryHackMe" only fills 9 of them, the last 7 blocks are padded with zeros.
- This ensures that the message length meets SHA-256’s processing rules before further transformations occur.

**Initial State Setup**

- The padded message is broken down into **smaller segments** for further processing.
- The animation above visually splits the message into **four distinct blocks**, each containing four characters. This segmentation allows SHA-256 to efficiently process the data step by step rather than working on the entire message at once.

**Hash Computation**

- SHA-256 applies a series of mathematical operations to transform the message.
- The four blocks are merged and processed using bitwise operations and modular arithmetic. The animation represents this transformation with a new **intermediate block labeled "GR9M"**, symbolizing that the original message has already started changing through computations.

**Final Hash Generation**

- The final transformation produces a **fixed-length 256-bit hash**.
- The animation shows the last computed block emerging as the final hash output, illustrating that the input message has been completely transformed.

![SHA-256 hashing process animation showing the a more detailed padding process.](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/1491a61594a7055ff656b45eee3c36ba.gif)

_Animation #2_

SHA-256 processes data in **512-bit blocks**, meaning that any input message must be **expanded** to fit this exact size. Each character in **"TryHackMe"** is converted into its **8-bit ASCII binary equivalent**:

| Character | ASCII (Decimal) | Binary Representation |
| --------- | --------------- | --------------------- |
| T         | 84              | 01010100              |
| r         | 114             | 01110010              |
| y         | 121             | 01111001              |
| H         | 72              | 01001000              |
| a         | 97              | 01100001              |
| c         | 99              | 01100011              |
| k         | 107             | 01101011              |
| M         | 77              | 01001101              |
| e         | 101             | 01100101              |

Once all characters are converted, the resulting **binary string is 72 bits long**:

```markdown
01010100 01110010 01111001 01001000 01100001 01100011 01101011 01001101 01100101
```

Since SHA-256 **requires 512 bits**, we must **extend** this binary string using **padding rules**. SHA-256 requires 512-bit blocks; we must extend the **72-bit message**. Padding is applied in three steps:

**1. Append a 1 Bit**

- A **single `1-bit`** is added to indicate the end of the actual message.
- The new length is now **73 bits**.  
    **Updated binary string:**

```markdown
01010100 01110010 01111001 01001000 01100001 01100011 01101011 01001101 01100101 1
```

**2. Add `375` Zeros**

- SHA-256 requires that **padding fill the message up to 448 bits** (leaving space for the length field).
- Since we now have **73 bits**, we add **375 zeros** to bring the total length to **448 bits**.

```markdown
01010100 01110010 01111001 01001000 01100001 01100011 01101011 01001101 01100101 1 00000000...00000000
```

**3. Append the Message Length (64 Bits)**

- The **original message length (72 bits)** is converted into a **64-bit binary representation**.
- The 72-bit message length in decimal is `72`, which converts to **`00110110 00110100`** in binary.
- This **64-bit length representation** is **appended to the message**.

Final **512-bit** message:

```markdown
01010100 01110010 01111001 01001000 01100001 01100011 01101011 01001101 01100101 1 00000000...00000000 00110110 00110100
```

Now that the message is **exactly 512 bits**, it is **forwarded to the Initial State Setup Block** for further processing.

![SHA-256 hashing process animation showing a more detailed initial state setup.](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/11dc4557a4cf8dd48294a629eaa3adf6.gif)

_Animation #3_

SHA-256 doesn’t process the entire 512-bit message at once; instead, it **breaks it down into smaller 32-bit blocks** and then **expands it further** into a 64-block structure. This step is crucial because it ensures that the message undergoes proper diffusion, allowing even small changes in input to have a significant impact on the final hash.

**1. Breaking Down the 512-bit Message**

The animation above starts by displaying the **padded 512-bit message from Animation 2** as one long sequence of binary values. However, since SHA-256 processes **32-bit words**, this sequence must be divided into smaller units.

To illustrate this, the animation **draws a red line**, visually **splitting the 512-bit message into 16 smaller blocks**, each containing **32 bits**. These blocks are labeled sequentially as **W[0] to W[15]**.

At this stage, the message still consists of only **16 blocks**, but SHA-256 requires **64 blocks** for processing. This means the existing blocks must be **expanded using a specific formula** to fill in the missing values from **W[16] to W[63]**.

**2. Expanding the Message – Computing W[16]**

To explain how new blocks are created, the animation zooms into a **single example calculation**—the creation of **W[16]**.

To the right of `W[16]`, the animation highlights four specific blocks from earlier in the sequence:

- `W[14]`
- `W[9]`
- `W[1]`
- `W[0]`

These blocks are used to compute `W[16]` using the following formula:

```markdown
W[16] = σ1(W[14]) + W[9] + σ0(W[1]) + W[0]
```

Each term in this equation is computed step by step:

1. **Computing σ1(W[14])**
    - The animation shows `W[14]` undergoing **bitwise operations**:
        - It is **rotated right by 17 bits**.
        - It is **rotated right by 19 bits**.
        - It is **shifted right by 10 bits**.
    - The results of these three operations are **XORed together**, producing `σ1(W[14])`.
2. **Adding W[9]**
    - The animation highlights `W[9]`, retrieves its value, and **adds it to the running sum**.
3. **Computing σ0(W[1])**
    - The animation repeats the **bitwise rotation and shift operations** for `W[1]`:
        - It is **rotated right by 7 bits**.
        - It is **rotated right by 18 bits**.
        - It is **shifted right by 3 bits**.
    - The results of these operations are **XORed together**, producing `σ0(W[1])`, which is added to the sum.
4. **Adding W[0]**
    - Finally, `W[0]` is retrieved and added, completing the calculation.

Once all values are combined, the animation **fills in `W[16]` with the final computed value**.

**3. Completing the Expansion to W[63]**

With `W[16]` computed, the animation zooms back out and **fast-forwards through the calculations** for the remaining blocks up to `W[63]`. These are filled sequentially using the same logic applied to `W[16]`, ensuring the entire **message schedule** is complete.

By the end of this step, all **64 blocks** (`W[0]` to `W[63]`) are generated, forming the **fully expanded message schedule** that will be used in the next phase of hashing.

**4. Introducing the Initial Hash Values (`H0` to `H7`)**

SHA-256 requires **starting hash values** that act as the foundation for all computations. These values are **predefined constants**, derived from the **first 32 bits of the fractional parts of the square roots of the first eight prime numbers**.

The animation above displays these **eight initial hash values** in separate labeled boxes:

- `H0 = 6a09e667`
- `H1 = bb67ae85`
- `H2 = 3c6ef372`
- `H3 = a54ff53a`
- `H4 = 510e527f`
- `H5 = 9b05688c`
- `H6 = 1f83d9ab`
- `H7 = 5be0cd19`

Each of these **32-bit blocks** is assigned to a corresponding **working variable** (`a, b, c, d, e, f, g, h`).

**5. Assigning Initial Hash Values to Working Variables**

To prepare for the next phase of computation, the animation **visually connects each hash value to its corresponding working variable**:

- `H0` is assigned to `a`.
- `H1` is assigned to `b`.
- `H2` is assigned to `c`.
- `H3` is assigned to `d`.
- `H4` is assigned to `e`.
- `H5` is assigned to `f`.
- `H6` is assigned to `g`.
- `H7` is assigned to `h`.

These working variables will be used in the **hash computation phase**, where they will be modified over 64 rounds of processing.

![SHA-256 hashing process animation showing the hash computation round 0.](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/f92ff4e19896a41fc6ba56dc273f17d5.gif)

_Animation #4_

At this stage in SHA-256, the **message has been expanded to 64 blocks** and the **initial hash values** have been set up. Now, the hashing function enters the **main computation phase**, where the message undergoes **64 rounds of processing**.

Each round applies a **series of mathematical transformations** to mix the message further and introduce diffusion, ensuring that **even a small change in input produces a completely different hash**.

This animation **zooms into the Hash Computation block** and walks through a **single round** in full detail before **fast-forwarding the remaining 63 rounds**.

**1. Initialize the Hash Computation Process**

The animation above begins with the following **inputs**:

1. **The 64 message blocks** (`W[0]` to `W[63]`) generated in Animation 3.
2. **The eight working variables** (`a, b, c, d, e, f, g, h`), which are initialized from the predefined hash values (`H0` to `H7`).

At the start of the first round, these values remain **unchanged from their initial states**.

**2. Processing a Single Round**

Since SHA-256 consists of **64 rounds**, the animation **focuses on the first round** to explain the step-by-step process before fast-forwarding the remaining rounds.

- The animation **highlights `W[0]`**, the **first message block**, as it is introduced into the computation.
- At the same time, **the round constant `K[0]`** is displayed.
- These values are used in calculations that modify the working variables.

Each round has a unique round constant (`K[i]`), which is a **predefined 32-bit value** derived from the fractional parts of the cube roots of the first 64 prime numbers.

**For the first round:**

```markdown
K[0] = 0x428a2f98
```

SHA-256 uses **two logical functions**, **Ch** and **Maj**, which help in mixing the data by selectively choosing and combining bits.

##### **Ch Function (Choice Function)**

- The function takes three inputs: `e`, `f`, and `g`.
    
- It is calculated as:
    
    ```markdown
    Ch(e, f, g) = (e AND f) XOR (NOT e AND g)
    ```
    
- The animation shows the values of `e`, `f`, and `g` being processed:
    
    - `e` decides which bits from `f` and `g` will be chosen.
    - If a bit in `e` is **1**, the corresponding bit from `f` is used.
    - If a bit in `e` is **0**, the corresponding bit from `g` is used.
- The XOR operation combines the selected bits, producing the `Ch` result.
    

##### **Maj Function (Majority Function)**

- The function takes three inputs: `a`, `b`, and `c`.
    
- It is calculated as:
    
    ```markdown
    Maj(a, b, c) = (a AND b) XOR (a AND c) XOR (b AND c)
    ```
    
- The animation highlights the values of `a`, `b`, and `c` being processed:
    
    - It selects the majority bit value among `a`, `b`, and `c`.
    - If at least **two out of three bits** are **1**, the result is **1**.
    - If at least **two out of three bits** are **0**, the result is **0**.

These functions help ensure that **bitwise patterns spread throughout the computation**.

SHA-256 applies two **sigma functions**, which introduce non-linearity through **bitwise rotations and shifts**.

##### **Σ1 Function (Applied to `e`)**

- The function is computed as:
    
    ```markdown
    Σ1(e) = ROTR(e, 6) XOR ROTR(e, 11) XOR ROTR(e, 25)
    ```
    
- The animation shows the bits in `e` being:
    
    - **Rotated right by 6 bits**.
    - **Rotated right by 11 bits**.
    - **Rotated right by 25 bits**.
- The results of these rotations are **XORed together** to produce `Σ1(e)`.
    

##### **Σ0 Function (Applied to `a`)**

- The function is computed as:
    
    ```markdown
    Σ0(a) = ROTR(a, 2) XOR ROTR(a, 13) XOR ROTR(a, 22)
    ```
    
- The animation shows the bits in `a` being:
    
    - **Rotated right by 2 bits**.
    - **Rotated right by 13 bits**.
    - **Rotated right by 22 bits**.
- The results of these rotations are **XORed together** to produce `Σ0(a)`.
    

Once all the required values are computed, they are **combined into two temporary values**:

```markdown
Temp1 = h + Σ1(e) + Ch + K[i] + W[i]
Temp2 = Σ0(a) + Maj
```

- The animation displays the **intermediate sum for Temp1**.
- The **intermediate sum for Temp2** is calculated separately.

These values will be used to **update the working variables**. After computing `Temp1` and `Temp2`, the values of the working variables (`a` to `h`) are updated as follows:

```markdown
h = g
g = f
f = e
e = d + Temp1
d = c
c = b
b = a
a = Temp1 + Temp2
```

- The animation visually **shifts the values**:
    - `h` takes the value of `g`.
    - `g` takes the value of `f`.
    - `f` takes the value of `e`.
    - `e` is updated to `d + Temp1`.
    - `d`, `c`, and `b` shift down.
    - `a` is updated to `Temp1 + Temp2`.

At the end of **one round**, the **values of `a` to `h` have changed**, marking **one step of diffusion**.

**3. Repeat the Computation for 64 Rounds**

- After **one full round**, the animation **fast-forwards through the remaining 63 rounds**.
- The values continue updating, spreading the message bits throughout the system.

**4. Update the Initial Hash Values (`H0` to `H7`)**

Once all **64 rounds** are completed, the final values of `a` to `h` are **added to the original hash values**:

```markdown
H0 = H0 + a
H1 = H1 + b
H2 = H2 + c
H3 = H3 + d
H4 = H4 + e
H5 = H5 + f
H6 = H6 + g
H7 = H7 + h
```

- The animation **adds the new values to the original hash values**.
- The result is **a new set of hash values**, which will be **used as the final hash**.

![SHA-256 hashing process animation showing the final hashing process.](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/bb391846823b0fdf146ba50a78f98ba7.gif)

_Animation #5_

At this stage, the SHA-256 algorithm has completed **64 rounds of computation**, and the working variables (`a` to `h`) have been **updated and modified** in every round. However, these variables alone are not the final hash yet.

The final step in the SHA-256 process is to **combine the modified values of `a` to `h` into a single 256-bit output hash**. This step is known as **Final Hash Generation**, where we take the **updated working variables, merge them, and present them as a fixed-length output**.

**1. Retrieve the Updated Hash Values (`H0` to `H7`)**

From **Animation 4**, we know that after the **64 rounds**, the **final values of the working variables (`a` to `h`)** were added to their respective **initial hash values (`H0` to `H7`)**.

These updated values now serve as the **final hash values** that will be combined to form the SHA-256 digest.

For the input **"TryHackMe"**, the final computed values are:

```markdown
H0 = 9e897fb7
H1 = e8832e7d
H2 = 6e5f63a4
H3 = bdbd0cd6
H4 = 496f53cb
H5 = 3f54b5ab
H6 = f84217d9
H7 = f4ca5397
```

The animation above starts by **displaying each of these values separately**, emphasizing that they are **the final results of all previous computations**.

**2. Concatenating the Eight Hash Values Into a 256-bit Block**

SHA-256 produces a **256-bit output**, which is formed by **joining the eight final hash values (`H0` to `H7`)**.

Since each `H` value is **32 bits long**, concatenating them results in:

```markdown
H0 + H1 + H2 + H3 + H4 + H5 + H6 + H7 = 256-bit final hash
```

To visually demonstrate this process, the animation does the following:

1. **Displays the eight hash values (`H0` to `H7`) in sequence**.
2. **Moves them toward each other**, merging them into a single **long binary block**.
3. **Shows the combined 256-bit binary representation**.

**3. Converting the Concatenated Binary Block to Hexadecimal**

Internally, SHA-256 operates on **binary values**, but the final output is typically displayed in **hexadecimal format** for readability.

To illustrate this, the animation **highlights each `H` value in its binary form**, then shows:

4. **The conversion of each 32-bit binary block into its hexadecimal equivalent**.
5. **The final hash as a concatenated hexadecimal string**.

The final SHA-256 digest for **"TryHackMe"** is:

```markdown
9e897fb7e8832e7d6e5f63a4bdbd0cd6496f53
```